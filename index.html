<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Sistema de Reconhecimento Facial AvanÃ§ado</title>

</head>
<body>
  <div class="container">
    <h1>ğŸ¤– Sistema de Reconhecimento Facial AvanÃ§ado ğŸ¤–</h1>
    <div class="split">
      <div class="panel">
        <h2>ğŸ“‹ INSTRUÃ‡Ã•ES</h2>
        <ol>
          <li>Clique em â€œLigar CÃ¢meraâ€</li>
          <li>Digite seu nome completo</li>
          <li>Siga as instruÃ§Ãµes de pose (olhar para lados, cima, baixo)</li>
          <li>Clique em â€œCapturar Rosto (20x)â€</li>
          <li>Aguarde atÃ© o status confirmar</li>
          <li>Veja seu nome na lista</li>
          <li>Selecione e clique em â€œExcluirâ€ para remover</li>
        </ol>
      </div>
      <div class="panel">
        <div class="video-container">
          <video id="videoFeed" autoplay playsinline></video>
        </div>
        <div class="progress-container">
          <div class="progress-bar" style="width: 0%"></div>
        </div>
        <div class="pose-instruction" id="poseText"></div>
        <div class="controls">
          <button id="btnStart">ğŸ¥ Ligar CÃ¢mera</button>
          <button id="btnCapture" disabled>ğŸ“¸ Capturar Rosto (20x)</button>
          <button id="btnStop" disabled>â¹ï¸ Desligar CÃ¢mera</button>
        </div>
        <input type="text" id="userName" placeholder="Digite seu nome completo"/>
        <div id="status">ğŸ”´ Status: Aguardando inicializaÃ§Ã£o</div>
        <div id="results"></div>
        <div class="manage">
          <select id="userList" multiple></select>
          <button id="btnDelete">ğŸ—‘ï¸ Excluir Cadastro</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.mjs';

    class FacialRecognitionSystem {
      constructor() {
        this.video = document.getElementById('videoFeed');
        this.faceDetector = null;
        this.cameraStream = null;
        this.isCapturing = false;
        this.captureCount = 0;
        this.currentPose = 0;
        this.poses = ['center', 'left', 'right', 'up', 'down'];
        this.faceDB = JSON.parse(localStorage.getItem('faceDB') || '{"users":[]}');
        this.initializeElements();
        this.initializeEventListeners();
      }

      initializeElements() {
        this.elements = {
          btnStart: document.getElementById('btnStart'),
          btnCapture: document.getElementById('btnCapture'),
          btnStop: document.getElementById('btnStop'),
          btnDelete: document.getElementById('btnDelete'),
          userName: document.getElementById('userName'),
          status: document.getElementById('status'),
          results: document.getElementById('results'),
          userList: document.getElementById('userList'),
          progressBar: document.querySelector('.progress-bar'),
          poseText: document.getElementById('poseText')
        };
      }

      initializeEventListeners() {
        this.elements.btnStart.addEventListener('click', () => this.startCamera());
        this.elements.btnCapture.addEventListener('click', () => this.startCapture());
        this.elements.btnStop.addEventListener('click', () => this.stopCamera());
        this.elements.btnDelete.addEventListener('click', () => this.deleteUser());
      }

      async initializeFaceDetector() {
        try {
          const fileset = await vision.FilesetResolver.forVisionTasks(
            'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm'
          );
          
          this.faceDetector = await vision.FaceDetector.createFromOptions(fileset, {
            baseOptions: {
              modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/latest/blaze_face_short_range.tflite',
              delegate: 'GPU',
            },
            runningMode: 'VIDEO',
            minDetectionConfidence: 0.85,
          });
          
          this.updateStatus('ğŸŸ¢ Sistema pronto');
        } catch (error) {
          this.handleError(`Erro na inicializaÃ§Ã£o: ${error.message}`);
        }
      }

      async startCamera() {
        try {
          this.cameraStream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              facingMode: 'user',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            } 
          });
          
          this.video.srcObject = this.cameraStream;
          await this.initializeFaceDetector();
          this.detectionLoop();
          this.updateControls(true);
          this.updateStatus('ğŸŸ¢ CÃ¢mera ativa');
        } catch (error) {
          this.handleError(`Erro na cÃ¢mera: ${error.message}`);
        }
      }

      async detectionLoop() {
        if (!this.faceDetector) return;
        
        const detect = async () => {
          if (this.video.readyState < 2) return;
          
          const detections = await this.faceDetector.detectForVideo(
            this.video, 
            performance.now()
          );

          if (detections.detections.length > 0) {
            this.processDetection(detections.detections[0]);
          }
          
          requestAnimationFrame(detect);
        };
        
        detect();
      }

      processDetection(detection) {
        this.drawFaceOverlay(detection);
        const embedding = detection.keypoints.flatMap(p => [p.x, p.y]);
        
        if (this.isCapturing) {
          this.handleCapture(embedding);
        } else {
          this.handleRecognition(embedding);
        }
      }

      drawFaceOverlay(detection) {
        const canvas = document.createElement('canvas');
        const rect = detection.boundingBox;
        canvas.className = 'face-overlay';
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;
        canvas.style.left = `${rect.originX}px`;
        canvas.style.top = `${rect.originY}px`;
        
        const container = document.querySelector('.video-container');
        container.querySelectorAll('.face-overlay').forEach(el => el.remove());
        container.appendChild(canvas);
      }

      startCapture() {
        if (!this.validateName()) return;
        
        this.isCapturing = true;
        this.captureCount = 0;
        this.currentPose = 0;
        this.updateProgress(0);
        this.updatePoseInstruction();
        this.elements.btnCapture.disabled = true;
        this.updateStatus('â³ Capturando poses...');
      }

      handleCapture(embedding) {
        if (this.captureCount >= 20) return this.stopCapture();
        
        if (performance.now() - this.lastCapture > 250) {
          this.captureCount++;
          this.lastCapture = performance.now();
          this.saveEmbedding(embedding);
          this.updateProgress((this.captureCount / 20) * 100);
          
          if (this.captureCount % 4 === 0) {
            this.currentPose++;
            this.updatePoseInstruction();
          }
        }
      }

      saveEmbedding(embedding) {
        const user = this.faceDB.users.find(u => u.name === this.elements.userName.value.trim()) || 
          { name: this.elements.userName.value.trim(), embeddings: [] };
        
        if (!user.embeddings) user.embeddings = [];
        user.embeddings.push(embedding);
        
        if (!this.faceDB.users.some(u => u.name === user.name)) {
          this.faceDB.users.push(user);
        }
        
        localStorage.setItem('faceDB', JSON.stringify(this.faceDB));
      }

      handleRecognition(embedding) {
        const matches = this.faceDB.users.flatMap(user => 
          user.embeddings.map(emb => ({
            name: user.name,
            similarity: this.calculateSimilarity(emb, embedding)
          }))
        );
        
        const bestMatch = matches.sort((a, b) => b.similarity - a.similarity)[0];
        
        if (bestMatch && bestMatch.similarity > 0.85) {
          this.elements.results.textContent = `ğŸ‘‹ Bem-vindo, ${bestMatch.name}! (${Math.round(bestMatch.similarity * 100)}%)`;
        } else {
          this.elements.results.textContent = '';
        }
      }

      calculateSimilarity(a, b) {
        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val ** 2, 0));
        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val ** 2, 0));
        return dotProduct / (magnitudeA * magnitudeB);
      }

      stopCapture() {
        this.isCapturing = false;
        this.elements.btnCapture.disabled = false;
        this.updateStatus(`âœ… ${this.elements.userName.value.trim()} cadastrado com sucesso!`);
        this.elements.userName.value = '';
        this.updateUserList();
      }

      updateControls(cameraActive) {
        this.elements.btnStart.disabled = cameraActive;
        this.elements.btnStop.disabled = !cameraActive;
        this.elements.btnCapture.disabled = !cameraActive;
      }

      updateStatus(message) {
        this.elements.status.textContent = message;
      }

      updateProgress(percentage) {
        this.elements.progressBar.style.width = `${percentage}%`;
      }

      updatePoseInstruction() {
        const instructions = [
          'Olhe diretamente para a cÃ¢mera',
          'Vire a cabeÃ§a para a esquerda',
          'Vire a cabeÃ§a para a direita',
          'Olhe para cima',
          'Olhe para baixo'
        ];
        this.elements.poseText.textContent = instructions[this.currentPose % 5];
      }

      validateName() {
        const name = this.elements.userName.value.trim();
        if (!name) {
          this.showAlert('Por favor, digite seu nome completo!');
          return false;
        }
        if (this.faceDB.users.some(u => u.name === name)) {
          this.showAlert('Este nome jÃ¡ estÃ¡ cadastrado!');
          return false;
        }
        return true;
      }

      showAlert(message) {
        const alert = document.createElement('div');
        alert.className = 'alert';
        alert.textContent = message;
        document.body.appendChild(alert);
        setTimeout(() => alert.remove(), 3000);
      }

      updateUserList() {
        this.elements.userList.innerHTML = '';
        this.faceDB.users.forEach(user => {
          const option = document.createElement('option');
          option.value = user.name;
          option.textContent = `${user.name} (${user.embeddings.length} amostras)`;
          this.elements.userList.appendChild(option);
        });
      }

      deleteUser() {
        const selected = this.elements.userList.value;
        if (!selected) return this.showAlert('Selecione um usuÃ¡rio para excluir!');
        
        if (confirm(`Tem certeza que deseja excluir ${selected}?`)) {
          this.faceDB.users = this.faceDB.users.filter(u => u.name !== selected);
          localStorage.setItem('faceDB', JSON.stringify(this.faceDB));
          this.updateUserList();
          this.updateStatus(`ğŸ—‘ï¸ ${selected} removido com sucesso`);
        }
      }

      stopCamera() {
        if (this.cameraStream) {
          this.cameraStream.getTracks().forEach(track => track.stop());
          this.video.srcObject = null;
        }
        this.updateControls(false);
        this.updateStatus('â¹ï¸ CÃ¢mera desativada');
        document.querySelectorAll('.face-overlay').forEach(el => el.remove());
      }

      handleError(message) {
        this.updateStatus(`ğŸ”´ Erro: ${message}`);
        console.error(message);
      }
    }

    const faceSystem = new FacialRecognitionSystem();
    faceSystem.updateUserList();
  </script>
</body>
</html>
